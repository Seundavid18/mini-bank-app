trigger:
- main

pool:
  vmImage: ubuntu-latest

parameters:
  - name: versioningScheme
    type: string
    default: "main-patch"
    values:
      - main-patch       # Increment patch version when merged to main
      - release-patch    # Increment patch version when merged to release branch
      - manual           # Manual major.minor.patch versioning

variables:
  MajorMinorVersion: "1.2"  # Manually set major.minor version
  PatchVersion: "0"         # Default patch version

steps:
# Checkout repository with full history
- checkout: self
  fetchDepth: 0

# Install jq for JSON parsing
- script: |
    echo "Installing jq for JSON processing..."
    sudo apt-get update
    sudo apt-get install -y jq
    jq --version
  displayName: "Install jq"

# Download and install GitVersion CLI
- script: |
    echo "Downloading GitVersion CLI..."
    wget https://github.com/GitTools/GitVersion/releases/download/5.11.1/gitversion-linux-x64-5.11.1.tar.gz -O gitversion.tar.gz
    mkdir gitversion
    tar -xzf gitversion.tar.gz -C gitversion
    export PATH="$PATH:$(pwd)/gitversion"
    echo "##vso[task.prependpath]$(pwd)/gitversion"
    chmod +x gitversion/gitversion
    echo "Verifying GitVersion installation..."
    gitversion/gitversion --version
  displayName: "Install GitVersion CLI"

# Run GitVersion and capture output in JSON format
- script: |
    echo "Running GitVersion..."
    gitversion/gitversion /output json /config gitversion.yml > gitversion_output.json
    echo "GitVersion output:"
    cat gitversion_output.json
  displayName: "Run GitVersion"

# Extract version from GitVersion output
- script: |
    echo "Extracting version from GitVersion output..."
    VERSION=$(cat gitversion_output.json | jq -r .FullSemVer)
    echo "Computed version: $VERSION"
    echo "##vso[task.setvariable variable=FULL_VERSION]$VERSION"
  displayName: "Extract and Set Version"

# Apply Logic
- script: |
    echo "Selected versioning scheme: ${{ parameters.versioningScheme }}"

    # Initialize variables
    majorMinor="$(MajorMinorVersion)"
    patch="$(PatchVersion)"

    if [ "${{ parameters.versioningScheme }}" == "main-patch" ] && [ "$BUILD_SOURCEBRANCHNAME" == "main" ]; then
      echo "Incrementing patch version for main branch."
      patch=$((patch + 1))
    elif [ "${{ parameters.versioningScheme }}" == "release-patch" ] && [[ "$BUILD_SOURCEBRANCHNAME" =~ ^release.* ]]; then
      echo "Incrementing patch version for release branch."
      patch=$((patch + 1))
    elif [ "${{ parameters.versioningScheme }}" == "manual" ]; then
      echo "Using manual major.minor.patch versioning. No auto-increment."
    else
      echo "No patch increment applied."
    fi

    # Combine major.minor and updated patch
    fullVersion="${majorMinor}.${patch}"
    echo "Computed version: $fullVersion"

    # Export version as pipeline variable
    echo "##vso[task.setvariable variable=FULL_VERSION]$fullVersion"
  displayName: "Compute Version Based on Parameter"

# Use Computed Version
- script: |
    echo "Building artifacts with version: $(FULL_VERSION)"
  displayName: "Use Computed Version"

# Install Node.js and NPM
- task: NodeTool@0
  inputs:
    versionSpec: '20.x'
  displayName: 'Install Node.js'

# NPM Install Steps
- task: Npm@1
  displayName: 'Install NPM in Client'
  inputs:
    command: 'install'
    workingDir: 'client'

- task: Npm@1
  displayName: 'Install NPM in Server'
  inputs:
    command: 'install'
    workingDir: 'server'

- task: Npm@1
  displayName: 'Install NPM in Test'
  inputs:
    command: 'install'
    workingDir: 'tests'

- task: Npm@1
  displayName: 'NPM Run Build'
  inputs:
    command: 'custom'
    workingDir: 'client'
    customCommand: 'run build'

# SonarCloud Analysis
- task: SonarCloudPrepare@1
  inputs:
    SonarCloud: 'Sonarcloud'
    organization: 'mini-bank-app'
    scannerMode: 'CLI'
    configMode: 'manual'
    cliProjectKey: 'mini-bank-app_mini-bank-app'
    cliProjectName: 'mini-bank-app'
    cliSources: '.'
    extraProperties: |
      sonar.verbose=true
      sonar.javascript.lcov.reportPaths: '**/coverage/lcov.info'
      sonar.exclusions=**/*.flow

- task: SonarCloudAnalyze@1

- task: SonarCloudPublish@1
  inputs:
    pollingTimeoutSec: '300'

# Copy Files
- task: CopyFiles@2
  displayName: 'Copy Client and Server Files'
  inputs:
    Contents: |
      client/build/**
      server/**
    TargetFolder: '$(Build.ArtifactStagingDirectory)'

- task: CopyFiles@2
  displayName: 'Copy Tests Files'
  inputs:
    Contents: |
      tests/**
      !tests/node_modules/**
    TargetFolder: '$(Build.ArtifactStagingDirectory)'

# Publish Build Artifacts
- task: PublishBuildArtifacts@1
  displayName: 'Publish Artifacts'
  inputs:
    PathtoPublish: '$(Build.ArtifactStagingDirectory)'
    ArtifactName: 'release'
    publishLocation: 'Container'

# Run Unit Tests
- task: Npm@1
  displayName: Unit tests
  inputs:
    command: 'custom'
    workingDir: 'tests'
    customCommand: 'run test'
  condition: succeededOrFailed()

- task: PublishTestResults@2
  displayName: 'Publish Test Results'
  inputs:
    testResultsFormat: 'JUnit'
    testResultsFiles: '**/test-results.xml'
    failTaskOnFailedTests: true
  condition: succeededOrFailed()

- task: Npm@1
  displayName: 'NPM install NYC in Test'
  inputs:
    command: 'custom'
    workingDir: 'tests'
    customCommand: 'install --save-dev nyc'

- task: PublishCodeCoverageResults@2
  displayName: 'Build code coverage report'
  inputs:
    codeCoverageTool: Cobertura
    summaryFileLocation: '$(System.DefaultWorkingDirectory)/coverage/cobertura-coverage.xml'
