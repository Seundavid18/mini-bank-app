trigger:
  - main
  - release

pool:
  vmImage: ubuntu-latest

parameters:
  - name: versioningScheme
    type: string
    default: "main-patch"
    values:
      - main-patch
      - release-patch
      - manual

  - name: multi_platform_tests
    type: boolean
    default: true
    displayName: "Enable Windows & Linux Unit Testing"

variables:
  MajorMinorVersion: "1.0"
  PatchVersion: "0"

stages:
  - stage: Build
    displayName: "Build & Install Dependencies"
    jobs:
      - job: InstallDependencies
        displayName: "Install Dependencies"
        steps:
          - checkout: self
            fetchDepth: 0

          - task: NodeTool@0
            inputs:
              versionSpec: '20.x'
            displayName: "Install Node.js"

          - task: Npm@1
            displayName: "Install NPM in Client"
            inputs:
              command: 'install'
              workingDir: 'client'

          - task: Npm@1
            displayName: "Install NPM in Server"
            inputs:
              command: 'install'
              workingDir: 'server'

          - task: Npm@1
            displayName: "Install NPM in Test"
            inputs:
              command: 'install'
              workingDir: 'tests'

          - task: Npm@1
            displayName: "Build Client"
            inputs:
              command: 'custom'
              workingDir: 'client'
              customCommand: 'run build'

          # **ðŸ“¦ Publish Artifacts**
          - task: CopyFiles@2
            displayName: "Copy Client & Server Files"
            inputs:
              Contents: |
                client/build/**
                server/**
              TargetFolder: '$(Build.ArtifactStagingDirectory)'

          - task: CopyFiles@2
            displayName: "Copy Test Files"
            inputs:
              Contents: |
                tests/**
                !tests/node_modules/**
              TargetFolder: '$(Build.ArtifactStagingDirectory)'

          - task: PublishBuildArtifacts@1
            displayName: "Publish Build Artifacts"
            inputs:
              PathtoPublish: '$(Build.ArtifactStagingDirectory)'
              ArtifactName: 'release-$(MajorMinorVersion).$(PatchVersion)'
              publishLocation: 'Container'

  - stage: Test
    displayName: "Run Unit Tests"
    jobs:
      - ${{ if eq(parameters.multi_platform_tests, true) }}:
          - job: Test_Linux
            displayName: "Unit Tests (Linux)"
            pool:
              vmImage: ubuntu-latest
            steps:
              - checkout: self

              - script: mkdir -p $(System.DefaultWorkingDirectory)/tests/coverage
                displayName: "Ensure Coverage Folder Exists"

              - task: Npm@1
                displayName: "Run Unit Tests (Linux)"
                inputs:
                  command: 'custom'
                  workingDir: 'tests'
                  customCommand: 'run test'
                condition: succeededOrFailed()

              - task: PublishTestResults@2
                displayName: "Publish Test Results (Linux)"
                inputs:
                  testResultsFormat: 'JUnit'
                  testResultsFiles: '**/test-results.xml'
                condition: succeededOrFailed()

              - task: PublishPipelineArtifact@1
                displayName: "Upload Coverage Report (Linux)"
                inputs:
                  targetPath: '$(System.DefaultWorkingDirectory)/tests/coverage'
                  artifact: 'Coverage_Linux'

          - job: Test_Windows
            displayName: "Unit Tests (Windows)"
            pool:
              vmImage: windows-latest
            steps:
              - checkout: self

              - script: mkdir $(System.DefaultWorkingDirectory)\tests\coverage
                displayName: "Ensure Coverage Folder Exists"
                condition: succeededOrFailed()

              - task: Npm@1
                displayName: "Run Unit Tests (Windows)"
                inputs:
                  command: 'custom'
                  workingDir: 'tests'
                  customCommand: 'run test'
                condition: succeededOrFailed()

              - task: PublishTestResults@2
                displayName: "Publish Test Results (Windows)"
                inputs:
                  testResultsFormat: 'JUnit'
                  testResultsFiles: '**/test-results.xml'
                condition: succeededOrFailed()

              - task: PublishPipelineArtifact@1
                displayName: "Upload Coverage Report (Windows)"
                inputs:
                  targetPath: '$(System.DefaultWorkingDirectory)/tests/coverage'
                  artifact: 'Coverage_Windows'

      - ${{ if eq(parameters.multi_platform_tests, false) }}:
          - job: Test_Single
            displayName: "Unit Tests (Single Platform)"
            pool:
              vmImage: ubuntu-latest
            steps:
              - checkout: self

              - script: mkdir -p $(System.DefaultWorkingDirectory)/tests/coverage
                displayName: "Ensure Coverage Folder Exists"

              - task: Npm@1
                displayName: "Run Unit Tests"
                inputs:
                  command: 'custom'
                  workingDir: 'tests'
                  customCommand: 'run test'
                condition: succeededOrFailed()

              - task: PublishTestResults@2
                displayName: "Publish Test Results"
                inputs:
                  testResultsFormat: 'JUnit'
                  testResultsFiles: '**/test-results.xml'
                condition: succeededOrFailed()

              - task: PublishPipelineArtifact@1
                displayName: "Upload Coverage Report (Single-Platform)"
                inputs:
                  targetPath: '$(System.DefaultWorkingDirectory)/tests/coverage'
                  artifact: 'Coverage_Single'

  - stage: SonarCloud
    displayName: "SonarCloud Analysis"
    dependsOn: Test
    condition: succeededOrFailed()
    jobs:
      - job: Sonar_Analysis
        displayName: "Run SonarCloud Analysis"
        steps:
          - download: current
            artifact: Coverage_Linux
            continueOnError: true
          - download: current
            artifact: Coverage_Windows
            continueOnError: true
          - download: current
            artifact: Coverage_Single
            continueOnError: true

          - script: |
              echo "Checking downloaded artifacts..."
              ls -R $(Pipeline.Workspace)/Coverage_Linux || echo "No Linux coverage"
              ls -R $(Pipeline.Workspace)/Coverage_Windows || echo "No Windows coverage"
              ls -R $(Pipeline.Workspace)/Coverage_Single || echo "No Single-Platform coverage"
            displayName: "Debug: List Coverage Artifacts"

          - task: SonarCloudPrepare@1
            inputs:
              SonarCloud: 'Sonarcloud'
              organization: 'mini-bank-app'
              scannerMode: 'CLI'
              configMode: 'manual'
              cliProjectKey: 'mini-bank-app_mini-bank-app'
              cliProjectName: 'mini-bank-app'
              cliSources: '.'
              extraProperties: |
                sonar.verbose=true
                sonar.javascript.lcov.reportPaths=$(Pipeline.Workspace)/Coverage_Linux/lcov.info,$(Pipeline.Workspace)/Coverage_Windows/lcov.info,$(Pipeline.Workspace)/Coverage_Single/lcov.info
                sonar.coverageReportPaths=$(Pipeline.Workspace)/Coverage_Linux/cobertura-coverage.xml,$(Pipeline.Workspace)/Coverage_Windows/cobertura-coverage.xml,$(Pipeline.Workspace)/Coverage_Single/cobertura-coverage.xml
                sonar.exclusions=**/*.flow

          - task: SonarCloudAnalyze@1

          - task: SonarCloudPublish@1
            inputs:
              pollingTimeoutSec: '300'

# trigger:
# - main
# - release

# pool:
#   vmImage: ubuntu-latest

# parameters:
#   - name: versioningScheme
#     type: string
#     default: "main-patch"
#     values:
#       - main-patch       # Increment patch version when merged to main
#       - release-patch    # Increment patch version when merged to release branch
#       - manual           # Manual major.minor.patch versioning

# variables:
#   MajorMinorVersion: "1.0"  # Manually set major.minor version
#   PatchVersion: "0"         # Default patch version

# steps:
# # Checkout repository with full history
# - checkout: self
#   fetchDepth: 0

# # Download and install GitVersion CLI
# - script: |
#     echo "Downloading GitVersion CLI..."
#     wget https://github.com/GitTools/GitVersion/releases/download/6.1.0/gitversion-linux-x64-6.1.0.tar.gz -O gitversion.tar.gz
#     mkdir gitversion
#     tar -xzf gitversion.tar.gz -C gitversion
#     export PATH="$PATH:$(pwd)/gitversion"
#     echo "##vso[task.prependpath]$(pwd)/gitversion"
#   displayName: "Install GitVersion CLI"

# # Run GitVersion and capture output
# - script: |
#     echo "Running GitVersion..."
#     ./gitversion/gitversion /output json /config gitversion.yml > gitversion_output.json
#     echo "GitVersion output saved."
#   displayName: "Run GitVersion"

# # Extract version from GitVersion
# - script: |
#     echo "Extracting version from GitVersion output..."
#     if [ -f gitversion_output.json ]; then
#         VERSION=$(cat gitversion_output.json | jq -r '.FullSemVer' || echo "")
#         if [ -z "$VERSION" ]; then
#             echo "Failed to extract version. Invalid or missing FullSemVer."
#             exit 1
#         fi
#         echo "Computed version: $VERSION"
#         echo "##vso[task.setvariable variable=GIT_FULL_VERSION]$VERSION"
#     else
#         echo "gitversion_output.json not found."
#         exit 1
#     fi
#   displayName: "Extract Version from GitVersion"

# # Apply Logic for Versioning
# - script: |
#     echo "Selected versioning scheme: ${{ parameters.versioningScheme }}"

#     # Start with the manually set Major.Minor version
#     majorMinor="${{ variables.MajorMinorVersion }}"
#     echo "Base Major.Minor version: $majorMinor"

#     # Extract patch version from GitVersion's FullSemVer
#     gitVersion=$(GIT_FULL_VERSION)
#     patch=$(echo "$gitVersion" | grep -oE '[0-9]+$')

#     # Increment patch based on branch and versioning scheme
#     if [ "${{ parameters.versioningScheme }}" == "main-patch" ] && [ "$BUILD_SOURCEBRANCHNAME" == "main" ]; then
#       echo "Incrementing patch version for main branch."
#       patch=$((patch + 1))
#     elif [ "${{ parameters.versioningScheme }}" == "release-patch" ] && [[ "$BUILD_SOURCEBRANCHNAME" =~ ^release.* ]]; then
#       echo "Incrementing patch version for release branch."
#       patch=$((patch + 1))
#     elif [ "${{ parameters.versioningScheme }}" == "manual" ]; then
#       echo "Using manual major.minor.patch versioning. No auto-increment."
#     else
#       echo "No patch increment applied."
#     fi

#     # Combine major.minor and updated patch
#     finalVersion="${majorMinor}.${patch}"
#     echo "Final computed version: $finalVersion"

#     # Export version as pipeline variable
#     echo "##vso[task.setvariable variable=FULL_VERSION]$finalVersion"
#   displayName: "Compute Version Based on Parameter"

# # Set Build Name with Commit Message and Full Version
# - script: |
#     echo "Updating pipeline name..."
    
#     # Retrieve the latest commit message
#     commitMessage=$(git log -1 --pretty=%s | tr -d '\n' | tr -d '\r')
    
#     # Sanitize the commit message
#     sanitizedCommitMessage=$(echo "$commitMessage" | sed 's/[^a-zA-Z0-9._-]/-/g')
    
#     # Combine Build ID and Full Version (exclude redundant commit message at the end)
#     buildName="#${BUILD_BUILDID} â€¢ $sanitizedCommitMessage $(FULL_VERSION)"
#     echo "Computed build name: $buildName"
    
#     # Update the build number
#     echo "##vso[build.updatebuildnumber]$buildName"
#   displayName: "Set Build Name"
#   env:
#     FULL_VERSION: $(FULL_VERSION)  # Pass FULL_VERSION as an environment variable

# # Install Node.js and NPM
# - task: NodeTool@0
#   inputs:
#     versionSpec: '20.x'
#   displayName: 'Install Node.js'

# # NPM Install Steps
# - task: Npm@1
#   displayName: 'Install NPM in Client'
#   inputs:
#     command: 'install'
#     workingDir: 'client'

# - task: Npm@1
#   displayName: 'Install NPM in Server'
#   inputs:
#     command: 'install'
#     workingDir: 'server'

# - task: Npm@1
#   displayName: 'Install NPM in Test'
#   inputs:
#     command: 'install'
#     workingDir: 'tests'

# - task: Npm@1
#   displayName: 'NPM Run Build'
#   inputs:
#     command: 'custom'
#     workingDir: 'client'
#     customCommand: 'run build'

# # SonarCloud Analysis
# - task: SonarCloudPrepare@1
#   inputs:
#     SonarCloud: 'Sonarcloud'
#     organization: 'mini-bank-app'
#     scannerMode: 'CLI'
#     configMode: 'manual'
#     cliProjectKey: 'mini-bank-app_mini-bank-app'
#     cliProjectName: 'mini-bank-app'
#     cliSources: '.'
#     extraProperties: |
#       sonar.verbose=true
#       sonar.javascript.lcov.reportPaths: '**/coverage/lcov.info'
#       sonar.exclusions=**/*.flow

# - task: SonarCloudAnalyze@1

# - task: SonarCloudPublish@1
#   inputs:
#     pollingTimeoutSec: '300'

# # Copy Files
# - task: CopyFiles@2
#   displayName: 'Copy Client and Server Files'
#   inputs:
#     Contents: |
#       client/build/**
#       server/**
#     TargetFolder: '$(Build.ArtifactStagingDirectory)'

# - task: CopyFiles@2
#   displayName: 'Copy Tests Files'
#   inputs:
#     Contents: |
#       tests/**
#       !tests/node_modules/**
#     TargetFolder: '$(Build.ArtifactStagingDirectory)'

# # Publish Build Artifacts
# - task: PublishBuildArtifacts@1
#   displayName: 'Publish Artifacts'
#   inputs:
#     PathtoPublish: '$(Build.ArtifactStagingDirectory)'
#     ArtifactName: 'release-$(FULL_VERSION)'
#     publishLocation: 'Container'

# # Run Unit Tests
# - task: Npm@1
#   displayName: Unit tests
#   inputs:
#     command: 'custom'
#     workingDir: 'tests'
#     customCommand: 'run test'
#   condition: succeededOrFailed()

# # Publish Unit Tests
# - task: PublishTestResults@2
#   displayName: 'Publish Test Results'
#   inputs:
#     testResultsFormat: 'JUnit'
#     testResultsFiles: '**/test-results.xml'
#     failTaskOnFailedTests: true
#   condition: succeededOrFailed()

# # Install NYC in tests
# - task: Npm@1
#   displayName: 'NPM install NYC in Test'
#   inputs:
#     command: 'custom'
#     workingDir: 'tests'
#     customCommand: 'install --save-dev nyc'

# # Publish Coverage results
# - task: PublishCodeCoverageResults@2
#   displayName: 'Build code coverage report'
#   inputs:
#     codeCoverageTool: Cobertura
#     summaryFileLocation: '$(System.DefaultWorkingDirectory)/tests/coverage/cobertura-coverage.xml'